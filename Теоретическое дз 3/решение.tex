\documentclass[12pt]{extarticle}
\usepackage[english, russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, portrait, margin=2.5cm]{geometry}
\usepackage{mathastext}
\usepackage{graphicx}
\usepackage{multirow}
\graphicspath{{images/}}
\newcommand\tab[1][1cm]{\hspace*{#1}}

\begin{document}

\section*{1}
Построим в каждой строке sparse table. Это работает за O(n * n log n)

Теперь сделаем вертикальную sparse table из всех строк. Единичные элементы уже есть - это sparse table на строках. Объединение двух строк в одну более широкую работает за O(n log n), по количеству элементов в массиве под sparse table. Нужно сделать n log n объединений, поэтому итоговая сложность $O(n^2 log^2 n)$.

\section*{2}
Узнать, является ли строка правильной скобочной последовательностью можно введя переменную, равную числу ( - число ) на префиксе. Если на любом префиксе эта переменная не становится отрицательной и в конце равна 0, то строка - правильная скобочная последовательность.

Посчитаем такую переменную p для всех префиксов. Это можно сделать за O(n).

Сделаем sparse table на минимум по этой переменной. Это можно сделать за O(n log n).

Теперь для каждого запроса (l, r) найдём минимум на отрезке (l, r) через sparse table. Если он $\ge$ p[l] и p[l] == p[r], то ответ - да, иначе - нет. Это можно сделать за O(1).

\section*{3}
Поместим каждый элемент в своё splay дерево. Это займёт O(n) времени.

Объединение двух деревьев работает за O(log n), запрос тоже.

Запрос: идём вверх от x пока правый сын не станет > x. Идём в правого сына, и потом влево донизу.

\section*{4}
в) $(\sum\limits_{l \le i \le r} a_i) ^ 2 = (a_l + a_{l + 1} + \dots) * (a_l + a_{l + 1} + \dots) = a_l^2 + a_{l + 1}^2 + \dots + a_l a_{l + 1} + a_l a_{l + 2} + \dots + a_{l + 1} a_l + a_{l + 1} a_{l + 2} + \dots$ 

$\sum\limits_{l \le i \le j \le r} a_i * a_j = \frac{(\sum\limits_{l \le i \le r} a_i) ^ 2 - \sum\limits_{l \le i \le r} a_i^2}{2}$
\newline
г) $\sum\limits_{l \le i \le j \le k \le r} a_i * a_j * a_k = \frac{(\sum\limits_{l \le i \le r} a_i) ^ 3 - \sum\limits_{l \le i \le r} a_i^3 - \sum\limits_{l \le i \le j \le r} a_i^2 * a_j}{6}$


\section*{5}
В вершине дерева отрезков будем хранить информацию по всем числам под ним. Числа ограничены 10 битами. В вершине будем хранить для каждого бита у всех ли контролируемых чисел этот бит равен 0, 1 или есть и то и то. 

Когда нужно сделать xor на отрезке, можно посмотреть на общую информацию по подотрезку. Если у всех чисел бит был 0, а в x этот бит = 1, то теперь у всех чисел он станет 1. И наоборот. Если были и 0 и 1, то так же и останется. Если в x этот бит = 0, то теперь у всех чисел этот бит 0.

В ответе на and 1 будет стоять в бите только если во всех контролируемых числах 1.


\end{document}