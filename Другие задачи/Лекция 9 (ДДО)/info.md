## Персистентные структуры данных

_хранится информация о всех предыдущих версиях_

### Персистентный массив

a[0], a[1], ... a[n-1]

запрос (v, pos, x) => a[pos] = x, v - новый номер версии

get(v, pos) - вывести a[pos] версии v

решение: для каждого pos храним историю его изменений. История - массив пар (v, x). v растёт, поэтому поиск в истории с помощью бинпоиска.

Изменение элемента за O\*(1)

Запрос за O(log q), q - общее количество запросов

### Персистентный стек

Можно сделать стек через массив, а персистентный массив уже есть.

Можно в добавок к стеку хранить массив топов. При каждом запросе push и pop добавляем в массив элемент stack.top(). Массив топов не уменьшается, индекс i в массиве = топ после запроса с номером i.

### Персистентное дерево отрезков

-> update(pos, x) *// создаётся новая версия*

-> getSum(v, l, r)  *// v - номер версииы*

идея как с массивом

другая идея: при изменении сына создавать новую ветку. Указатель на неизменённого сына копируется из предыдущей версии

