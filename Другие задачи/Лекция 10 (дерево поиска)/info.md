Храним множество S

Методы:

1. find x : ответить на вопрос "x in S?"

2. insert x : добавить x в S

3. erase x : удалить x из S

Опционально:

1. merge S1, S2

2. split S k -> S[x <= k>], S[x > k]

### Наивное дерево поиска

Храним множество в бинарном дереве.

Для вершины со значением x: Слева все дети меньше x, справа больше

find x за O(h), h - глубина дерева

insert x (x в дереве отсутствует): идём от корня до листа, потом подвешиваем x с нужной стороны к этому листу. Работает за O(h).

erase x (x присутствует): спускаемя до вершины x. Если у вершины нет детей или 1 ребёнок, то удаляем x и перемещаем его ребёнка на освободившееся место.

Если 2 сына: пусть m - минимум в правом поддереве вершины x. У m нет левого сына. Поэтому сделаем erase(m), а m переместим на место x.

### AVL дерево

Сбалансированное дерево поиска: h = log_2 n

Бинарное дерево поиска называется AVL деревом, если для любой вершины v модуль разности глубин поддеревьев <= 1.

В вершине хранятся значение, h, \Delta, указатели на детей и указатель на родителя.

*Утверждение*: AVL дерево на n вершинах имеет глубину logn.

*Доказательство*: Пусть S(h) - минимальное количество вершин в AVL дереве глубины h.

S(0) = 0, S(1) = 1

S(h) = 1 + S(h - 1) + S(h - 2)

S(2) = 2, S(3) = 4, S(4) = 7, S(5) = 12, S(6) = 20

S(h) = F\_{h+2} - 1, h >= 0

S(h) = \Theta (\phi^h) -> глубина дерева O(log\_\phi n)

#### Вращение

Направо: левый сын корня становится корнем, предыдущий корень спускается направо. Все поддеревья этих двух вершин перемещаются единственным возможным способом.

Налево: корень спускается влево, корнем становится правый сын.

#### Как использовать вращение

\Delta(v) = h(L) - h(R) in {-1, 0, 1}

Плохие ситуации: \Delta = +- 2

\Delta = -2 -> вращение налево. Надо рассмотреть случаи для \Delta правого сына. Если \Delta(R) = 1, то надо ещё сделать вращение вправо для правого сына.

insert x: Добавление элемента как в наивном дереве. Потом идём вверх и исправляем все \Delta.

### Splay дерево

*Определение*: бинарное дерево поиска, такое что элемент, к которому был последний запрос (find, insert), находится в корне дерева.

zig (x) // x - сын корня // : если x - левый сын - вращение направо. Если x - правый сын - вращение налево.

zigzig(x) // x - не сын корня, два предка по одной стороне (оба левые дети или оба правые) // : два одинаковый вращения (чтобы поднять x)

zigzag(x) // два предка по разные стороны от своих родителей // : два разных поворота, чтобы поднять x

splay(x) - комбинация zigzig / zigzag и возможно одного zig

после каждого find(x) надо вызвать splay от самой низкой посещённой вершины

insert x, erase x - вызов splay от последней посещённой вершины

*Утверждение*: амортизированные время обработки каждого запроса - O*(logn)



