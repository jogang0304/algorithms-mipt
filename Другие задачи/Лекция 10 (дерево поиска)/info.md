Храним множество S

Методы:

1. find x : ответить на вопрос "x in S?"

2. insert x : добавить x в S

3. erase x : удалить x из S

Опционально:

1. merge S1, S2

2. split S k -> S[x <= k>], S[x > k]

### Наивное дерево поиска

Храним множество в бинарном дереве.

Для вершины со значением x: Слева все дети меньше x, справа больше

find x за O(h), h - глубина дерева

insert x (x в дереве отсутствует): идём от корня до листа, потом подвешиваем x с нужной стороны к этому листу. Работает за O(h).

erase x (x присутствует): спускаемя до вершины x. Если у вершины нет детей или 1 ребёнок, то удаляем x и перемещаем его ребёнка на освободившееся место.

Если 2 сына: пусть m - минимум в правом поддереве вершины x. У m нет левого сына. Поэтому сделаем erase(m), а m переместим на место x.

### AVL дерево

Сбалансированное дерево поиска: h = log_2 n

Бинарное дерево поиска называется AVL деревом, если для любой вершины v модуль разности глубин поддеревьев <= 1.

В вершине хранятся значение, h, \Delta, указатели на детей и указатель на родителя.

_Утверждение_: AVL дерево на n вершинах имеет глубину logn.

_Доказательство_: Пусть S(h) - минимальное количество вершин в AVL дереве глубины h.

S(0) = 0, S(1) = 1

S(h) = 1 + S(h - 1) + S(h - 2)

S(2) = 2, S(3) = 4, S(4) = 7, S(5) = 12, S(6) = 20

S(h) = F\_{h+2} - 1, h >= 0

S(h) = \Theta (\phi^h) -> глубина дерева O(log\_\phi n)

#### Вращение

Направо: левый сын корня становится корнем, предыдущий корень спускается направо. Все поддеревья этих двух вершин перемещаются единственным возможным способом.

Налево: корень спускается влево, корнем становится правый сын.

#### Как использовать вращение

\Delta(v) = h(L) - h(R) in {-1, 0, 1}

Плохие ситуации: \Delta = +- 2

\Delta = -2 -> вращение налево. Надо рассмотреть случаи для \Delta правого сына. Если \Delta(R) = 1, то надо ещё сделать вращение вправо для правого сына.

insert x: Добавление элемента как в наивном дереве. Потом идём вверх и исправляем все \Delta.

### Splay дерево

_Определение_: бинарное дерево поиска такое, что элемент, к которому был последний запрос (find, insert), находится в корне дерева.

zig (x) // x - сын корня // : если x - левый сын - вращение направо. Если x - правый сын - вращение налево.

zigzig(x) // x - не сын корня, два предка по одной стороне (оба левые дети или оба правые) // : два одинаковый вращения (чтобы поднять x)

zigzag(x) // два предка по разные стороны от своих родителей // : два разных поворота, чтобы поднять x

splay(x) - комбинация zigzig / zigzag и возможно одного zig

после каждого find(x) надо вызвать splay от самой низкой посещённой вершины

insert x, erase x - вызов splay от последней посещённой вершины

---

_Утверждение_: амортизированные время обработки каждого запроса - O\*(log n)

S(x) - размер поддерева x

r(x) = log_2 S(x) -- ранг вершины

F = Sum(r(v)) - потенциал

p, g - два предка

r' -- ранг в повернутом дереве (после zigzig)

a(zigzig) = 2 + r'(x) + r'(p) + r'(g) - r(g) - r(p) - r(x)

r(g) = r'(x)

a(zigzig) <= 2 + r'(g) + r'(x) - 2r(x) <= 3(r'(x) - r(x))

a(zigzag) = 2 + r'(x) + r'(p) + r'(g) - r(g) - r(p) - r(x)

r(g) = r'(x)

a(zigzag) <= 2 + r'(p) + r'(g) - 2r(x) <= 3(r'(x) - r(x))

a(zig) <= 1 + 3(r'(x) - r(x))

=> a(splay) <= 1 + 3(r_final(x) - r_initial(x)) = O(log n)

=> t(splay) = O\*(log n)

find не изменяет потенциал, t(find) = t(splay)

---

merge: _все элементы левого дерева < всех элементов правого_

Находим подходящий x в правой ветке левого дерева. Splay(x). Левый сын x - левое дерево, правый - правое.

---

split(k) - разбить на два дерева. В левом все элементы <= k, в правом все > k.

Найдём наибольший элемент <= k. Пусть это x. Splay(x).

Левое дерево - x и его левое поддерево. Правое дерево - правое поддерево x.
