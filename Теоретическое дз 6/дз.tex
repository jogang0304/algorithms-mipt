\documentclass{extarticle}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{geometry}
\usepackage{listings}
\geometry{a4paper, margin=2cm}

\title{Головин Иван, Б05-306}

\begin{document}
\maketitle

\section*{1}
Отсортируем гвозди по возрастанию координаты.
\newline
Очевидно, что первый гвоздик нужно соединить со вторым.
\newline
Третий гвоздик можно соединить со вторым или с четвёртым. Будем хранить два массива a и b. В массиве a будем хранить длину ниток, если мы соединили гвоздик i с i-1. В массиве b храним длину ниток, если не соединили. i от 1 до n. a[1] = none, b[1] = 0, a[2] = l[1, 2], b[2] = none. Далее, a[i] = min(a[i-1], b[i-1]) + l[i-1, i], b[i] = a[i-1]. Ответом будет a[n].
\newline
Асимптотика O(n log n) из-за сортировки.

\section*{2}
Сделаем двухмерный массив dp.
\newline
В dp[i][j], i < j хранится сколько нужно минимально переправ для перевоза грузов с i по j, и сколько свободного места есть в последней переправе.
\newline
dp[i][i] = $\{1, t - w[i]\}$
\newline
dp[i][j] =
\begin{lstlisting}
    if (dp[i + 1][j].first < dp[i][j - 1].first) {
        if (dp[i + 1][j].second >= w[i]) {
            dp[i][j] = {dp[i + 1][j].first, dp[i + 1][j].second - w[i]}
        } else {
                dp[i][j] = {dp[i + 1][j].first + 1, t - w[i]}
        }
    } else if (dp[i + 1][j].first > dp[i][j - 1].first) {
        if (dp[i][j - 1].second >= w[j]) {
            dp[i][j] = {dp[i][j - 1].first, dp[i][j - 1].second - w[j]}
        } else {
            dp[i][j] = {dp[i][j - 1].first + 1, t - w[j]}
        }
    } else {
        if (dp[i + 1][j].second >= dp[i][j - 1].second) {
            if (dp[i + 1][j].second >= w[i]) {
                dp[i][j] = {dp[i + 1][j].first, dp[i + 1][j].second - w[i]}
            } else {
                dp[i][j] = {dp[i + 1][j].first + 1, t - w[i]}
            }
        } else {
            if (dp[i][j - 1].second >= w[j]) {
                dp[i][j] = {dp[i][j - 1].first, dp[i][j - 1].second - w[j]}
            } else {
                dp[i][j] = {dp[i][j - 1].first + 1, t - w[j]}
            }
        }
    }
\end{lstlisting}
Ответом будет dp[1][n].first.

\section*{3}

Разобьём элементы на группы по $\sqrt{n}$ элементов. Решим задачу о рюкзаке для каждого из них за $O(W\sqrt{n} \cdot \sqrt{n}) = O(Wn)$ времени и $O(W\sqrt{n})$ памяти. На каждую группу тратится $O(W\sqrt{n})$ памяти, и надо хранить верхний слой каждой из уже подсчитанных групп. Для каждого веса в этом слое надо хранить битовую маску используемых предметов. Каждая маска занимает $O(log n)$ памяти. При переходе к следующему слою все предыдущие слои масок нужно объединить, поэтому в любой момент времени будет только один слой с масками для восстановления ответа. Длина слоя W, количество групп $\sqrt{n}$. Поэтому суммарно памяти используется $O(W\sqrt{n} + W log n) = O(W\sqrt{n})$. Ещё n памяти уходит на сохранение исходного массива.

\section*{4}
Так как $a_i \geq 2a_{i-1}$, то разбиение W будет содержать $O(log W)$ элементов.

Найдём элемент $a_p$ такой, что $a_{p+2} \leq K$ и $p$ максимален. Тогда сумма a от 1 до p $\leq a_{p+2} \leq K$.

Построим динамику dp[i][j] - количество способов разбить i используя первые j элементов.

$dp[i][j] = dp[i - a_j][j - 1] + dp[i][j - 1]$

Разобьём a на два множества: A$\{a_1, \dots a_{p+1}, a_{p+1}\}$ и B$\{a_{p+2}, \dots a_n, a_n\}$. В A найдём количество способов разбить K за $O(K log K)$ времени, а в B - количество способов разбить $W - K$ за $O(F_{log_2 (W/K)})$.

\section*{5}
а, б) Введём динамику dp[i][j] - минимум $f$, при использовании j чисел общей суммой i. Ответом будет dp[m][n].

Если есть два множества A и B, то $f(A \cup B) = f(A) + f(B) + \sum_{i=1}^{|A|} a_i \sum_{j=1}^{|B|} \frac{1}{b_j}$

Сделаем переход динамики: $dp[i][2j] = min_{1<H<|B|}^{1<t<i}(dp[t][j] + dp[i-t][j] + tH)$, где H - сумма обратных элементов множества, сумма которого = i - t. Делаются двоичные спуски, на каждом шаге нужно перебрать m значений t и $|H|$ значений H. Асимптотика $O(m|H| log n)$.

Число значений H оценивается $O(m)$, поэтому такая динамика будет работать за $O(m^2 log n)$.

\section*{6}
MASK - начальная маска, для которой считается $a'$.

Докажем требуемое утверждение по индукции.

База n = 1: mask $\in \{0, 1\}$. Если MASK = 0, то после прохождения алгоритма в a[MASK] будет a[MASK]. Если MASK = 1, то mask = 0. После прохождения алгоритма в a[MASK] будет a[MASK] + a[0]. В обоих случаях утверждение верно.

Переход к n, если для n - 1 верно: MASK[n-1] = 1, тогда после прохождения алгоритма в a[MASK] будет a[MASK] + a[mask]. Учитывая, что утверждение для n-1 верно, а mask[n-1] = 0, то a[mask] при i=n-1 уже равно $a'[mask]$. Тогда a[MASK] = $a'[MASK]$. Утверждение верно.

Задача решена, по коду видно, что дополнительной памяти не привлекается.

\section*{7}
Создадим массив d<bool>[i], i от 0 до W. d[i] = true, если можно набрать вес i. d[0] = true. Для каждого предмета $a_i$ будем обновлять массив d. d[j] = true, если d[j] = true или d[j - w[i]] = true. Ответом будет максимальный индекс i, такой что d[i] = true.

Получается, что d на новом шаге это xor старого d и сдвинутого на w[i] старого d. Можно хранить d как $\frac{W}{\omega}$ битовых маск. Тогда операции сдвига и xor для одной маски будут работать за $O(1)$. Получается асимптотика $O(n\frac{W}{\omega})$.

\section*{8}

а, б, в) Можно перебрать все варианты кубиков для n $\leq 18$. Это произойдёт за константное время. Потом из полученных значений можно восстановить исходную формулу. Значит асимптотика $O(1)$.



\end{document}