\documentclass[12pt]{extarticle}
\usepackage[english, russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, portrait, margin=2.5cm]{geometry}
\usepackage{mathastext}
\usepackage{graphicx}
\usepackage{multirow}
\graphicspath{{images/}}
\newcommand\tab[1][1cm]{\hspace*{#1}}

\begin{document}

\section*{1}

Запустим алгоритм Флойда, который найдёт минимальные расстояния d между всеми вершинами. \\
Если из вершины i есть путь в j, из j в k, и из k в i, то значит есть цикл, содержащий эти три вершины. Его длина = $d[i][j] + d[j][k] + d[k][i]$. \\
Переберём все тройки вершин i, j, k и найдём цикл минимального веса. \\
Если хранить дополнительный массив next, то можно восстанавливать путь между вершинами за O(n).
\begin{figure}[h]
    \centering
    \includegraphics*[width=0.7\textwidth]{Флойд.png}
\end{figure}
\newline
Итоговая сложность = Флойд + перебор троек + 3 восстановления пути ($i \to j, j \to k, k \to i$) = $O(n^3)$.

\section*{2}
Добавим в граф вершину s, и проведём от неё до каждой другой вершины ребро веса 0. Запустим алгоритм Форда-Беллмана из s, получив массив d - кратчайшие расстояния от s до вершин.\\
Пройдёмся по всем рёбрам (u, v), и если d[u] + w[u][v] = d[v], то оставим это ребро, иначе удалим.\\
В обновлённом графе найдём какой-то цикл. Если цикл есть, то он обязательно нулевой длины, иначе одно ребро из него можно было бы удалить по принципу выше. Формально, если есть цикл C из вершин $c_1, c_2, \dots c_k$, то
\[
    0 = d[c_1] = d[c_k] + w[c_k][c_1] = d[c_{k-1}] + w[c_{k-1}][c_k] + w[c_k][c_1] = \dots = d[c_1] + length(C)
\]
\[
    length(C) = 0
\]
\newline
Если цикла нет, то в исходном графе не было цикла длины 0.
\newline
Асимптотика - Форд-Беллман + проверка всех рёбер + поиск циклов (dfs) = O(nm + m + n + m) = O(nm)

\section*{3}
Установим нижнюю и верхнюю границы l и r на ответ. Будем применять бинпоиск.\\
\[m = \frac{l + r}{2}\]
Теперь вес каждого ребра = его вес минус m.\\
С помощью алгоритма Форда-Беллмана найдём цикл отрицательный цикл. Если он есть, то значит есть цикл со средним весом рёбер не больше m. Тогда l = m, и переходим к следующей итерации. Если нет, то r = m.\\
Так идём до тех пор, пока $r - l > \varepsilon$.\\
Всего будет сделано $log (\frac{r - l}{\varepsilon})$ итераций.\\
Асимптотика = Форд-Беллман * количество итераций = O(nm) * O($log (\frac{r - l}{\varepsilon})$) = $O(nm log(\frac{C}{\varepsilon}))$, потому что r и l выбираются на основе C.

\section*{4}
\subsection*{а}
Применим алгоритм Дейкстры на бинарной куче. Только надо поменять определение минимальной вершины на требуемое в условии (максимум из весов ребёр до вершины, а не сумма).

\subsection*{б}
С помощью dfs определим m - средний вес рёбер в графе.\\
Пройдёмся dfs по графу и удалим все рёбра, вес которых больше m.\\
Если путь между требуемыми вершинами пропал, то граф разбился на компоненты связности, в каждой из которых пути между двумя вершинами стоят не больше m.\\
Все вершины в одной компоненте связности можно объединить, потому что ответ больше чем m, и такое объединение безопасно с точки зрения корректности ответа.\\
Переходим к новой итерации, начиная с пересчёта m.

На каждой итерации количество рёбер уменьшается в 2 раза, поэтому будет не больше чем $\sum_{i=0}^\infty \frac{m}{2^i} = 2m$ итераций. Количество вершин тоже уменьшается. dfs каждый раз будет работать всё быстрее, и поэтому итоговая асимптотика будет O(2(n + m)) = O(n + m).

\section*{5}
Добавим вершину, соответствующую $x_0 = 0$. Заменим неравенства $x_i \leq c$ на $x_i \leq x_0 + c$\\
Для всех неравенств $x_i \leq x_j + c$ проведём ребро от вершины j к вершине i с весом c.\\
Запустим алгоритм Форда-Беллмана из вершины 0, найдя массив d расстояний до всех вершин.\\
Если были посещены все вершины, то значения переменных легко восстанавливаются, если идти по графу от 0 вершины. Если есть непосещённые вершины, то ответ - бесконечность (есть переменные, не ограниченные константой).\\
Асимптотика - O(nm) от Форда-Беллмана и O(n + m) от dfs для восстановления ответа = O(nm)

\end{document}