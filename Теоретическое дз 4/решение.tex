\documentclass[12pt]{extarticle}
\usepackage[english, russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, portrait, margin=2.5cm]{geometry}
\usepackage{mathastext}
\usepackage{graphicx}
\usepackage{multirow}
\graphicspath{{images/}}
\newcommand\tab[1][1cm]{\hspace*{#1}}

\begin{document}

\section*{3}
Делаем дерево поиска с ключами - номерами дверей. Также в вершине храним, сколько дверей с меньшими номерами было уничтожено.
\newline
Сначала дерево пустое. На запросе уничтожения двери k добавляем в дерево вершину с ключом k и значением 1. Потом идём вверх. Если текущая вершина является левым сыном, то значение в родителе увеличиваем на 1.
\newline
При запросе просмотра двери k, ищем её в дереве, пока не найдём или не дойдём до nullptr. Сохраняем сумму значений в вершинах, которые мы посещаем. Возвращаем k минус сумма.

\section*{4}
Делаем дерево поиска по мискам. Ключ - максимум из i и $t_i$. В вершинах храним количество вершин в левом поддереве.
\newline
После построения дерева за O(nlogn) ищем вершину с максимальным ключом <= T за O(logn). В процессе прохода от корня считаем, сколько вершин имеют меньший ключ. Все эти миски (с меньшим ключом) можно съесть.

\end{document}