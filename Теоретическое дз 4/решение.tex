\documentclass[12pt]{extarticle}
\usepackage[english, russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, portrait, margin=2.5cm]{geometry}
\usepackage{mathastext}
\usepackage{graphicx}
\usepackage{multirow}
\graphicspath{{images/}}
\newcommand\tab[1][1cm]{\hspace*{#1}}

\begin{document}

\section*{2}
Высота дерева - логарифмическая. Поэтому чтобы пронести элемент вниз, нужно сделать хотя бы логарифм сравнений.

\section*{3}
Делаем дерево поиска с ключами - номерами дверей. Также в вершине храним, сколько дверей с меньшими номерами было уничтожено.
\newline
Сначала дерево пустое. На запросе уничтожения двери k добавляем в дерево вершину с ключом k и значением 1. Потом идём вверх. Если текущая вершина является левым сыном, то значение в родителе увеличиваем на 1.
\newline
При запросе просмотра двери k, ищем её в дереве, пока не найдём или не дойдём до nullptr. Сохраняем сумму значений в вершинах, которые мы посещаем. Возвращаем k минус сумма.

\section*{4}
Делаем дерево поиска по мискам. Ключ - максимум из i и $t_i$. В вершинах храним количество вершин в левом поддереве.
\newline
После построения дерева за O(nlogn) ищем вершину с максимальным ключом <= T за O(logn). В процессе прохода от корня считаем, сколько вершин имеют меньший ключ. Все эти миски (с меньшим ключом) можно съесть.


\section*{5}
Строим дерево поиска по детям. Ключ - индекс ребёнка в изначальном массиве. Также сохраняем в вершине, сколько элементов в её левом поддереве. По этому можно узнать индекс ребёнка в текущем массиве (который уменьшается).
\newline
В данный момент времени в круге k детей, а последний выбывший имел индекс m. Тогда следующий выбывший имеет индекс $(m + a[i]) \% k$ в текущем массиве. Удаляем его из дерева. Уменьшаем k на 1, обновляем m.
\newline
Когда в дереве остался один ребёнок, возвращаем его индекс в изначальном массиве.

\end{document}